https://www.youtube.com/watch?v=icqzGct4V1s

# 다익스트라 최단 경로 알고리즘

다익스트라 최단 경로 알고리즘은 그래프에서 여러 개의 노드가 있을 때, 특정한 한 노드에서 출발하여 다른 노드로 가는 각각의 최단경로를 구해주는 알고리즘이다.

다익스트라 알고리즘은 '음의 간선'이 없을 경우, 정상적으로 작동한다.  
따라서, 현실세계에서 GPS 소프트웨어의 기본 알고리즘으로 채택 되곤 한다.

다익스트라 최단 경로 알고리즘은 기본적으로 그리디 알고리즘으로 분류 된다.  
그 이유는 매번 '가장 비용이 적은 노드'를 선택해서 임의의 과정을 반복 하기 때문이다.

# 다익스트라 원리

```
1. 출발 노드를 설정 한다. (start)
2. 최단 거리 테이블을 INF값으로 초기화 시킨다.
3. 방문 하지 않은 노드 중 최단 거리가 가장 짧은 노드를 선택한다. 
4. 해당 노드를 거쳐 다른 노드로 가는 비용을 계산하여 기존 저장 되어있는 비용과 비교하여 최단 거리 테이블을 갱신해준다.  

5. 3,4번 과정을 계속 반복해준다. -> 3,4번을 한단계라고 했을 때, 한단계당 하나의 노드에 대한 최단거리를 확실히 찾읗 수 있다.

```

# 간단한 다익스트라 알고리즘 소스코드 - 시간 복잡도(O(V^2)).

느리게 동작하긴 하지만, 구현하기 간단하기 때문에 이해를 위해 O(V^2)의 시간복잡도를 갖는 다익스트라 알고리즘을 작성하겠다.

1단계 (위의 3,4과정)를 진행할 때마다 방문하지 않은 노드 중에서 최단 거리가 가장 짧은 노드를 선택하기 위해 매 단계마다  
1차원 리스트의 모든 원소를 확인(순차탐색)하기 때문에 O(V^2)의 시간 복잡도를 갖게 된다.

-> 정리: O(V)번에 걸쳐서 최단 거리가 가자 짧은 노드를 선형 탐색해야 하고, 현재 노드와 연결된 노드를 일일이 확인하기 때문에 O(V^2)의 시간 복잡도를 갖는다

따라서, 노드의 개수가 10000개를 넘어가는 문제에서는 이코드로 문제 해결이 힘들다. -> 개선된 다익스트라 알고리즘의 탄생

# 개선된 다익스트라 최단경로 알고리즘

전 page에서의 다익스트라 알고리즘을 개선하여 O(ElogV)의 시간복잡도를 보장하는 알고리즘을 설명할 것이다. (E: 간선 개수, V: 노드 개수)

간단한 다익스트라 알고리즘은 '최단 거리가 가장 짧은 노드'를 찾기 위해서, 매번 최단 거리 테이블을 선형적으로 (모든 원소를 앞에서부터 하나씩) 탐색했다. (O(V))

그러나, 개선된 다익스트라 알고리즘에서는 힙 자료구조를 사용하여 '최단 거리가 가장 짧은 노드'를 찾는 과정을 선형 시간이 아닌 로그시간으로 처리를 한다.  
(N = 100만 , logN = 약 20)

힙 자료구조에 대해서는 자료구조 목록에 자세히 서술해 놨다.  
https://github.com/murjune/today_junelog/blob/main/algorithm/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/%ED%9E%99-%EC%9A%B0%EC%84%A0%EC%88%9C%EC%9C%84%20%ED%81%90/1.%20%EA%B0%9C%EC%9A%94.md

# 개선된 다익스트라 최단경로 소스코드- (ElogV)

시간 복잡도 개념도 중요하지만, 최소한 다익스트라 최단 경로 알고리즘의 소스코드를 잘 기억해두어야 한다.

여러번 반복 숙달하자!

```
시간 복잡도 계산

다익스트라 알고리즘의 시간 복잡도는 최대 E개의 간선 데이털를 힙에 넣었다가 다시 빼는 것으로 볼 수 있으므로 O(ElogE)라고 볼 수 있다.

이때! 중복 간선을 포합하지 않을 경우(오는 간선 가는 간선만 존재하는 경우)

E(간선) <V^2(노드)를 만족한다. 왜냐하면, 모든 노드끼리 서로 다 연결 되었다고 했을 떄 간선의 개수를 약 V^2로 볼 수 있고, E는 항상 V^2보다 작기 때문이다.  

정리하면, logE < logV^2이다. -> logE < 2 * logV 이는 logE = logV라고 볼 수 있다.  
따라서, 다익스트라 알고리즘의 전체 시간 복잡도를 계산하면 O(ElogV )이다.

```

입력값:
6 11
1
1 2 2
1 3 5
1 4 1
2 3 3
2 4 2
3 2 3
3 6 5
4 3 3
4 5 1
5 3 1
5 6 2

출력값:
0
2
3
1
2
4

```
``` python

def dijkstra(start):
    q = []
    import heapq
    # 시작 노드로 가기 위한 최단 경로는 0으로 설정하여, 큐에 삽입
    heapq.heappush(q,(0,start))
    distance[start] = 0
    while q:
        # 가장 최단 거리가 짧은 노드에 대한 정보 꺼내오기

        dist, now = heapq.heappop(q)

        # 현재 노드가 처리 된적이 있으면 무시
        if distance[now] < dist:
            continue
        # 현재 노드와 연결된 다른 인접 노드들 탐색

        for next in graph[now]:
            cost = distance[now] + next[1]

            if cost < distance[next[0]] :
                distance[next[0]] = cost
                heapq.heappush(q, (cost, next[0]))




import sys
input =lambda : sys.stdin.readline().rstrip()
INF = int(1e9) # 무한을 의미하는 값으로 10억 설정 - int값을 꼭 씌워줘야함

# 노드 개수, 간선의 개수
n, v =map(int,input().split())
# 시작 노드 번호로 입력 받기
start = int(input())
# 각 노드에 연결되어 있는 노드에 대한 정보를 담는 graph
graph = [[]for i in range(n+1)]

# 최단 거리 테이블: 모두 INF으로 초기화
distance = [INF]*(n+1)

# 모든 간선 정보를 입력 받기

for _ in range(v):
    a, b, c = map(int,input().split())
    # a노드 -> b노드 가는 가중치 c
    graph[a].append((b, c))

dijkstra(start)

for i in range(1,n+1):
    if distance[i] == INF:
        print(-1)
    else:
        print(distance[i])
```

