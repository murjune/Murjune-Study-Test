코루틴은 중단 가능한 작업 단위입니다.

- 코루틴은 동시성 프로그래밍을 최대한 쉽게 구현할 수 있도록 구현된 도구다

코루틴은 실행이 중단될 때 작업의 실행 환경을 Continuation 이라는 상태 머신에 저장을 하여 다시 resume 될 때 
중단된 지점부터 다시 실행할 수 있다는 특징이 있습니다. 이에 비해 스레드는 단순히 멈추는 것만 가능할 뿐 저장이 불가능합니다.

중단됐을 때 코루틴은 어떤 자원도 사용하지 않습니다. 따라서, 코루틴은 다른 스레드에서 시작할 수도 있고, 컨티뉴에이션 객체를 통해 다시 실행될 수 있

비동기적인 방식으로 코드 작성을 위해 불필요한 스레드를 많이 만들어야한다
```kotlin
showProgressBar()
thread {
    // 서버 통신
}.join() // mainThread 블로킹
hideProgressBar()
```
그래서 다음과 같이 하는게 좋음

```kotlin
import kotlin.concurrent.thread

thread {
    showProgressBar()
    thread {
        // 서버 통신
    }.join() // mainThread 블로킹
    hideProgressBar()
}

thread {
    showProgressBar()
    thread {
        // 서버 통신
        postHideProgressBar() // 만약 해당 작업을 취소하려해보자 -- 어떻게 취소할래?
    }
}
```

벌써 2개의 스레드를 생성하였음, 게다가 해당 thread 에서 예외가 발생하거나 작업을 취소하기도 어려움

코루틴을 활용하면 어떨까?

```kotlin
launch {
    showProgressBar()
    withContext(Dispatchers.IO) {
        // 서버 통신
    }
    hideProgressBar()
}
```
해당 코드에서는 스레드를 새롭게 생성해서 사용하는 부분은 없다.
IO 디스패처가 담당하는 스레드풀에서 이미 생성되어 있는 스레드에 코루틴을 할당하여 서버 통신을 진행하고 있다.
 코루틴은 IO 작업이 끝날 때까지 중단된다. 
이때 스레드가 중단되는 것이 아니라 코루틴이 중단되는 것이다.
즉, main 스레드가 블로킹되지 않는다는 것인데 이것이 가능한 이유는 중단되는 시점에 해당 코루틴을 탈출하기 때문이다.
그리고 IO 작업이 모두 마치면 중단되고 있던 코루틴을 메인 스레드에 분배하고 resume 시켜 중단된 지점부터 다시 작업을 이어나갈 수 있도록 한다.

즉, 스레드를 블로킹시키는 것이 아닌 코루틴을 중단시키는 것이다.



스레드의 단점)

- 스레드가 실행되었을 때, 멈출 수 있는 방법이 없어 메모리 누수로 이어질 수 있다 
- 스레드를 많이 생성하면 비용이 많이 든다 (스레드 스택의 기본 크기는 1MB 이다. 즉 많이 잡아먹는다)
- 스레드를 자주 전환하면 복잡도를 증가
- 코드량이 늘어난다

중단 가능하는 개념이 없다 그래서 기존 스레드 방식은 실행 흐름 제어하기가 굉장히 어렵고
람다를 넘겨주어야 한다. 코루틴의 경우 내부적으로 Continuation 을 활용한 콜백으로 wrapping이 되어 있어 비동기적인 코드를
개발자 마치 동기적인 방식으로 코드를 작성할 수 있습니다. (개발 편의성 및 가독성이 높다)

콜백 - 특정 작업이 끝난 후 어떤 작업 실행해야하는 동기적인 코드 흐름을 구현하기 위한 방법, non-blocking 한 방법으로 사용해야함  