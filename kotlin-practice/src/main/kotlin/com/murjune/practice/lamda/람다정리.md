


[람다 식](https://en.wikipedia.org/wiki/Lambda_expression): 기본적으로 다른 함수에 넘길 수 있는 작은 코드 조각

람다를 사용하면 쉽게 공통 코드 구조를 lib function 으로 뽑아낼 수 있다?

수신 객체 지정 람다: 람다 선언을 둘러싸고 있는 환경과는 다른 상황에서 람다 본문을 실행 가능하다.

람다가 왜 그렇게 중요할까??

- 람다의 쓰임새
1) callback: 특정 이벤트가 발생하면(함수 호출하면) 이 로직을 수행하자(handle)
2) calculate: 데이터 구조의 모든 원소에 이 연산을 적용하자!  

일련의 동작을 변수에 저장하거나 다른 함수로 넘겨야하는 경우가 자주 있다.

이전에는) 익명 class 를 통해 해당 작업을 했다. 왜냐면, 익명 객체는 변수에 담거나 함수 파라미터로 담을 수 있으니

그러나, 익명 class 를 사용하는 것은 boiler plate 코드를 많이 만든다.  
람다식을 사용하면 코드가 더 간결해진다.  

람다식을 사용하면 따로 함수를 선언하거나 익명 객체를 만들 필요도 없어 간결하다!  

멤버 참조: 단지 함수나 프로퍼티를 반환하는 역할을 수행하는 람다는 멤버 참조로 대치할 수 있다. - 

멤버 참조의 장점)

더 짧고 이해하기 쉬움

# 람다식과 변수 포획

자바 메서드 안에서 익명 클래스 내부에서 메서드의 로컬 변수를 익명 클래스 내부에 사용할 수 있다.  
람다 또한 동일하다.  

람다를 함수 안에서 정의하면 함수의 파라미터 뿐 아니라 람다 정의의 앞에 선언된 로컬 변수까지 람다에서 모두 사용가능하다.  

자바와 다른점!!
- 코틀린 람다 안에서는 파이널 변수가 아닌 변수에도 접근이 가능하다는 점이다.  
- 또한, 람다 안에서 바깥의 변수를 변경해도 된다.  

람다 안에서 사용하는 이부 변수를 `람다가 포획(capture)한 변수`라 한다.  

기본적으로 함수 안에 정의된 로컬 변수의 생명주기는 함수가 반환되면 끝난다.  

람다를 실행 시점에 표현하는 데이터 구조는 람다에서 

## [closure](https://en.wikipedia.org/wiki/Closure_(computer_programming))

클로저는 함수 내부에서 정의된 익명 함수가 외부 범위의 변수를 캡처하고 저장할 수 있는 특성을 의미합니다.  
따라서 자바와 코틀린에서 익명 객체(객체 식) 안의 코드가 포함된 함수의 변수에 접근할 수 있는 것은 클로저의 특성에 해당합니다.
A closure is a record storing a function together with an environment.
(클로저란 함수를 그 환경과 함께 저장한 레코드를 말한다.)
A closure is the combination of a function bundled together (enclosed) with references to its surrounding state (the lexical environment).
(클로저는 함수와 그 주변 상태에 대한 참조의 조합이다.)
이제 익명 객체 안에서 그 식이 포함된 함수의 변수에 접근할 수 있다는 것을 간단히 표현하기 위해 클로저라고 표현하겠다.

(사실 자바에서는 공식적으로 클로저 개념을 갖고 있지 않으며  클로저 기능이 다른 언어에 비해 한계점이 있다고 한다.)

자바와 코틀린 모두에서 익명 객체(객체 식) 안의 코드는 그 식이 포함된 함수의 변수에 접근할 수 있다.

이처럼 자신을 포함하고 있는 외부함수보다 내부함수가 더 오래 유지되는 경우, 외부 함수 밖에서 내부함수가 호출되더라도 외부함수의 지역 변수에 접근할 수 있는데 이러한 함수를 클로저(Closure)라고 부른다.


**컴파일러는 자동으로 그런 무명 클래스와 인스턴스를 만들어준다!**  

컴파일러가 만들어준 무명클래스에 있는 유일한 추상 메서드를 구현할 때 람다 본문을 메서드 본문으로 사용한다.  
(ex. Runnable run 이 그런 추상 메서드)  

### 람다식 vs 익명 객체  

객체를 명시적으로 선언하는 경우 메서드를 호출할 때마다 객체가 생성된다.  





